##  Apocalypse zombie slayer

##  Project Overview

This project is a 2D zombie survival game built using Python and the Pygame module. The game pits the player against various types of zombies that increase in difficulty over time. The player can move around the game world, swing a weapon to defeat enemies, pick up loot (such as health boxes), and use an in-game shop to purchase temporary buffs or permanent weapon upgrades. As the game progresses, the enemy spawn rate, attack complexity, and difficulty scale upward to keep the gameplay engaging and challenging.

## Project Review

I got the idea from the game I like to play named “Suvival.io” which is also a zombie killing game. However my project will require more improvement such as money to buy stuff from shops, points to unlock skill trees, and various kinds of zombies.

##  Programming Development

###  3.1 Game Concept
The objective of this game is to survive as long as possible by killing zombies, earning money, upgrading weapons, and leveling up. The player controls a character who navigates across a 2D world filled with zombies, collects loot for health, and upgrades abilities to enhance combat performance.

### 3.2  Object-Oriented Programming Implementation
- Game
Controls overall game state. It initializes and holds game components (player, enemies, loot drops, projectiles, UI elements like the shop and skill tree, and the database), manages the game loop (updating and drawing game elements, handling spawning, collisions, and levels), and signals game over.
- Database
Collects and records game statistics at regular intervals (now every 10 seconds). It tracks metrics such as damage taken, net coins collected, zombies killed, the number of player attacks (e.g., left mouse clicks), and the types of zombies killed. It then saves these statistics to a CSV file for later analysis by your visualization UI.
- Player
Represents the user’s character. It handles movement, health, experience, and special abilities (like the earthquake). It also tracks an attack_count (incremented when the player left-clicks) and contains a Weapon instance to manage combat.
- Weapon
Is associated with the Player and defines the player’s attack mechanics. It handles the swinging action, collision detection with enemies, applying damage to zombies, and triggering related effects (e.g., registering the type of zombie killed).
- LootDrops
Manages the spawning and drawing of loot items (such as health boxes) dropped by defeated enemies. It checks when the player collects these items and applies effects (such as restoring health).
- Shop
Provides a user interface for purchasing upgrades or items during gameplay. It interacts with the Game instance to change game parameters based on player choices. (Its implementation serves as part of your UI interactions.)
- SkillTree
Is the in-game UI that lets the player upgrade skills or abilities. Like Shop, it interacts with the Game to apply upgrades but focuses on a different set of enhancements for the player.
- Zombie (and its subclasses: SpeedyZombie, TankyZombie, SpitterZombie, KingZombie)
Models enemy behavior. The base Zombie class defines fundamental properties and functions (like moving toward the player and drawing itself). Each subclass specializes in attributes such as speed, health, or attack method, making for varied enemy behavior.
- Projectile
Represents any bullet or other projectile in the game. It updates its position and checks for collisions (e.g., against the player or boundaries), contributing to the dynamics of combat when used by the player or enemies.
- CustomStatsApp (from data_show.py)
Implements a Tkinter-based graphical user interface that reads the CSV file generated by the Database class and visualizes the collected game statistics using Pandas, Seaborn, and Matplotlib. This UI lets you explore graphs (boxplots, scatter plots, bar plots, etc.) reflecting player and enemy data over time.
Each of these classes works together to form your game’s system—from managing gameplay and collecting data to visualizing statistics.

![alt text](images/image.png)



###  3.3 Algorithms Involved
1.Pathfinding/Movement Algorithm: Zombies use a simple vector-based technique to calculate the direction and move incrementally towards the player's position.
2.Random Spawning: The game uses a randomized interval combined with weighted probabilities to spawn different types of zombies, ensuring varied enemy encounters.
Collision Detection: Pygame’s rectangle collision functions for both combat weapon hit detection and pickups loot collection.

## Statistical Data (Prop Stats)
### 4.1 Data Features

1. total damage player taken evry 10 sec: line graph

2.total coin player collect with in 10sec: bar graph

3.total zombie killed every within 10 sec: scatter plot

4.player attack count with in 10sec: boxplot

5.types of zombie killed: table




### 3.2 Data Recording Method
- Tracking Data:
The game uses the Database class to track several metrics during gameplay—such as the damage taken by the player, net coins collected, the number of zombies killed, how many times the player attacked (left-clicked), and the types of zombies killed. These metrics are stored in corresponding lists (e.g., damage_taken, coin_collect, zombie_killed, player_attack_count, and zombie_type).
- Periodic Sampling:
Every 10 seconds, the Database.update() method is called during the game loop. This method computes the difference between the current game state (like the current coin count or number of zombie kills) and the values recorded in the previous interval. For example, if the coin count increased, that increase is logged; if not (or if negative), a zero is recorded. The same is done for player attacks (by comparing the current attack_count with the value from the last update).
- Appending Data:
Once these differences (or new values) are computed, they are appended to the respective lists. Meanwhile, the types of zombies killed are recorded immediately via the register_zombie_kill() method.









